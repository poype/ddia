选择NoSQL数据库的几个考虑因素：

- 相比于关系型数据库具有更好的扩展性，包括支持超大数据集或超高**写入**吞吐量。
- 开源免费。
- 关系模型不能很好的支持一些特定的查询操作。
- 对关系模型的一些限制感到沮丧，希望有更具动态和表达力的数据模型。

举了一个关于简历的例子：一个人可以包含一个以上的工作，多段教育经历和任意数量的联系方式，即一对多的关系。

![image-20241001215315326](./image/image-20241001215315326.png)

关系模型是将职位、教育和联系方式放在单独的表中，并使用Foreign Key引用users表。

但对于简历这样的数据结构，它主要是一个**自包含**的文档，因此用Json表示非常合适。

```json
{
   "user_id":251,
   "first_name":"Bill",
   "last_name":"Gates",
   "summary":"Co-chair of the Bill & Melinda Gates... Active blogger.",
   "region_id":"us:91",
   "industry_id":131,
   "photo_url":"/p/7/000/253/05b/308dd6e.jpg",
   "positions":[
      {
         "job_title":"Co-chair",
         "organization":"Bill & Melinda Gates Foundation"
      },
      {
         "job_title":"Co-founder, Chairman",
         "organization":"Microsoft"
      }
   ],
   "education":[
      {
         "school_name":"Harvard University",
         "start":1973,
         "end":1975
      },
      {
         "school_name":"Lakeside School, Seattle",
         "start":null,
         "end":null
      }
   ],
   "contact_info":{
      "blog":"http://thegatesnotes.com",
      "twitter":"http://twitter.com/BillGates"
   }
}
```

json表示相比表模式具有更好的**局部性**。如果用关系模型，当读取一份简历数据时就需要查询多个表的数据。而对于json表示方法，所有相关信息都在一个地方，一次查询就够了。

## 多对一与多对多关系

简历例子中的region_id 和 industry_id 定义为ID。这是因为 region 和 industry 的所有值都是标准化的列表，可以支持用户从下拉列表中选择，这样可以有助于：

- 所有简历保持样式和输入值一致。
- 易于更新：名字只保存一次，如果需要改变（例如，由于政治事件而更改城市名字），可以很容易的全面更新。
- 本地化支持：当网站被翻译成其它语言时，标准化列表更方便本地化。
- 更好的搜索支持。

当使用ID时，对人类有意义的信息（例如这里的region和industry）只存储在一个地方，如果要引用region的值，那就引用对应的ID。

如果不使用ID，那使用它的每条记录都要保存一份region的值。

使用ID的好处是，因为ID对人类没有任何直接意义，所以永远不需要直接改变。任何对人类有意义的东西都可能在将来某个时刻发生改变。如果这些信息被复制，那么所有冗余副本就都需要被更新。这会导致更多的写入开销，并存在数据不一致的风险。

**这种就是多对一关系（多个人同时对应一个region值）**。

**多对一和多对多关系采用“文档模型”存储数据并没有绝对的优势。**

文档模型适合存储一对多关系的数据，因为所有数据可以存储成一个json，而不用分别存储在不同的表。这种局部性优势，对查询性能也有帮助。

但是，在表示多对一和多对多关系时，关系数据库和文档数据库并没有根本的不同。在应对这两种类型的关系时，相关项都由唯一的标识符引用，该标识符在关系模型中被称为Foreign Key，在文档模型中被称为**文档引用**。

由于关系数据库支持Join操作，可以很方便地一次查询多个相关联table的数据。

但文档数据库一般不支持Join操作，则应用层只能通过多次查询来模拟Join操作。

#### 自己思考

应用层通过多次查询来模拟Join操作其实也不是什么大问题。

《阿里数据库规范》中就强制不能使用外键，一切外键必须在应用层解决。还规定超过三张表时禁止Join。

外键和Join操作适合单机低并发，不适合分布式、高并发集群。外键还会影响数据的写入速度。

而且在应用层执行外键检查 和 执行多次查询模拟Join操作 也不是很麻烦的事。

所以文档数据库不支持Join操作，不能很好的表示多对一和多对多关系这一点并不能说是一个很大的缺点。

**而且很多应用程序可能永远都不会用到多对多关系！！！**

## 数据结构模式

大多数文档数据库，都不会对文档中的数据强制执行任何模式，没有模式意味着可以将任意的key-value添加到文档中。

文档数据库并不是完全没有模式，因为读数据的代码通常会采用某种模式检查，只是这个模式检查不是由数据库强制执行的。

更准确的术语应该是**读时模式**（数据的结构是隐式的，只有在读取时才解释），与**写时模式**（模式是显示的，数据写入时就必须遵守）相对应。

当应用程序需要改变数据格式时，文档模型应对会更加方便。

关系模型就需要更改表结构，更改表结构可能还需要update一下表中所有的历史数据，而Alter Table和Updata全表数据都是非常“重”的操作。

如果数据并不都具有相同的结构，例如：

- 有许多不同类型的对象，每种类型的对象都保存在各自的表中太不现实。
- 数据的结构由无法控制的外部系统所决定，而且可能随时改变。

这些情况下，模式带来的害处大于它所能提供的帮助，无模式的文档就更加适合。

文档数据库的目标用例是数据来自于自包含文档，且一个文档与其它文档之间的关联很少。

文档数据模型更加灵活，局部性存储会带来更好的性能。关系模型则强在Join操作、多对一和多对多关系更简洁的表达上。



















